---
layout: post
title: "指针"
author: "ZJM"
categories: code/algorithm/basic-knowledge
tags: [Code]
image: code-cover-8.png
---

# <span style="color: rgb(255,127,80);">**指针教程**</span>

学习 C++ 中的指针既简单又有趣。通过指针，可以简化一些编程任务，例如动态内存分配，而这些任务没有指针是无法完成的。因此，掌握指针是成为优秀 C++ 程序员的重要一步。

每个变量都有一个内存地址，可以使用地址运算符 `&` 来获取这个地址。下面是一个简单的例子，展示了如何打印变量的内存地址：

<span style="color: rgb(238,130,238);">**示例代码**</span>

```cpp
#include <iostream>
using namespace std;
int main()
{
    int var1;
    char var2[10];
    cout << "var1 变量的地址： " << &var1 << endl;
    cout << "var2 变量的地址： " << &var2 << endl;
    return 0;
}
```

当上面的代码编译并执行时，可能会输出类似以下内容：

```yaml
var1 变量的地址： 0xbfebd5c0
var2 变量的地址： 0xbfebd5b6
```

通过这个例子，你可以看到 `var1` 和 `var2` 的内存地址是不同的。接下来，我们将介绍什么是指针。

### <span style="color: rgb(0,191,255);">**什么是指针？**</span>

指针是一个变量，它存储另一个变量的内存地址。你可以通过指针间接地访问内存中的数据。指针变量需要在使用前声明，声明的语法如下：

```cpp
type *pointerName;
```

其中：
- `type` 是指针所指向数据的类型。
- `pointerName` 是指针变量的名称。

星号 `*` 用于声明一个指针，它不同于乘法中的 `*` 运算符，在这里它的作用是指示一个变量是指针类型。以下是一些有效的指针声明示例：

```cpp
int    *ip;    // 整型指针
double *dp;    // 双精度浮点型指针
float  *fp;    // 浮点型指针
char   *ch;    // 字符型指针
```

虽然指针的类型可以不同（整型、浮点型等），但它们存储的值始终是一个内存地址，通常以十六进制表示。

### <span style="color: rgb(0,191,255);">**如何使用指针**</span>

指针的常见操作包括：
1. **定义指针变量**
2. **将变量的地址赋给指针**
3. **通过指针访问变量的值**

你可以使用 `*` 运算符来访问指针指向的内存位置中的值。下面是一个具体示例：

<span style="color: rgb(238,130,238);">**示例代码**</span>

```cpp
#include <iostream>
using namespace std;
int main()
{
    int var = 20;   // 声明一个整数变量
    int *ip;        // 声明一个指向整数的指针
    ip = &var;      // 将 var 的地址赋给指针 ip
    cout << "var 变量的值： " << var << endl;
    cout << "ip 指针存储的地址： " << ip << endl;
    cout << "*ip 指针指向的值： " << *ip << endl;
    return 0;
}
```

运行结果：
```yaml
var 变量的值： 20
ip 指针存储的地址： 0xbfc601ac
*ip 指针指向的值： 20
```

在这个例子中：
- `&var` 获取变量 `var` 的地址，并将其赋值给指针 `ip`。
- 使用 `*ip` 来访问指针 `ip` 指向的内存位置的值，即 `var` 的值。

### <span style="color: rgb(0,191,255);">**C++ 指针的常见概念**</span>

在 C++ 中，指针有许多重要的概念，下面是一些基本概念：

| **概念**                    | **描述**                                                   |
|-----------------------------|------------------------------------------------------------|
| **空指针（NULL 指针）**       | `NULL` 是一个值为零的常量，用于表示指针不指向任何有效的内存地址。  |
| **指针运算**                | 可以对指针进行算术运算：`++`（指向下一个内存单元）、`--`（指向前一个内存单元）、`+`（增加偏移量）、`-`（减少偏移量）。 |
| **指针与数组**              | 数组名本身就是一个指向数组首元素的指针，因此，指针和数组之间有密切关系。 |
| **指针数组**                | 可以定义一个数组，该数组存储多个指针。                         |
| **指向指针的指针**           | C++ 允许定义指向指针的指针（即指针的指针），这种结构有时用于多维数组。 |
| **传递指针给函数**           | 通过传递指针，可以使得函数内修改传递给它的变量。                 |
| **函数返回指针**             | 函数可以返回指向局部变量、静态变量或动态分配内存的指针。         |

### <span style="color: rgb(0,191,255);">**1.C++ Null 指针**</span> 

在 C++ 中，如果指针在声明时没有明确的地址可以赋值，给指针变量赋值为 `NULL` 是一种良好的编程习惯。一个赋值为 `NULL` 的指针被称为空指针。

#### <span style="color: rgb(32,178,170);">**什么是 NULL 指针？**</span> 

`NULL` 指针是一个常量，它的值为零，表示指针不指向任何有效的内存地址。使用空指针有助于避免程序中出现未初始化的指针，从而减少错误和调试难度。

<span style="color: rgb(238,130,238);">**示例代码**</span>

```cpp
#include <iostream>
using namespace std;
int main()
{
    int *ptr = NULL;   // 将指针初始化为 NULL
    cout << "ptr 的值是 " << ptr << endl;
    return 0;
}
```

当代码编译并运行时，输出将是：

```
ptr 的值是 0
```

在这个例子中，`ptr` 是一个空指针，它的值是 `NULL`，即零。大多数操作系统都不允许访问地址为 0 的内存，因为该内存地址通常是操作系统保留的。因此，指向 `0` 的指针被认为是一个无效指针，通常不指向任何合法的内存位置。

### <span style="color: rgb(32,178,170);">**如何检查空指针**</span> 

在程序中，你可能需要检查一个指针是否为空。你可以使用 `if` 语句来检查指针是否为 `NULL`，例如：

```cpp
if (ptr) 
{
    // 如果 ptr 非空，则执行此代码块
} 
else 
{
    // 如果 ptr 为空，则执行此代码块
}
```

或者：

```cpp
if (!ptr) 
{
    // 如果 ptr 为空，则执行此代码块
}
```

### <span style="color: rgb(32,178,170);">**空指针的好处**</span> 

- **避免误用未初始化的指针**：指针在声明后，如果没有赋初值，它可能包含一些垃圾值，这可能会导致程序错误或崩溃。通过将未使用的指针初始化为 `NULL`，可以确保它不指向任何非法的内存地址，从而减少因误用未初始化指针而引发的问题。
  
- **提高代码的可读性和可维护性**：给指针赋 `NULL` 值是一种良好的编码规范，帮助其他开发者了解该指针尚未指向有效的数据，避免出现不必要的错误。

### <span style="color: rgb(32,178,170);">**总结**</span> 

空指针（`NULL`）是 C++ 中的一种指针，它指向一个无效的内存位置（地址为 0）。使用空指针可以有效防止程序中使用未初始化的指针，减少错误的发生，并提高代码的稳定性和可维护性。通过 `if` 语句可以方便地检查指针是否为空，帮助你做出正确的逻辑判断。

### <span style="color: rgb(0,191,255);">**2.C++ 指针的算术运算**</span>

指针是一个存储内存地址的变量，因此你可以对指针进行算术运算。C++ 允许对指针执行四种基本的算术运算：`++`（递增）、`--`（递减）、`+`（加法）、`-`（减法）。这些运算根据指针的类型和大小来决定移动的距离。

#### <span style="color: rgb(32,178,170);">**I. 递增指针（`++`）**</span> 

指针递增时，会使指针指向下一个内存位置，通常是下一个数组元素。递增的偏移量取决于指针所指向的数据类型大小。例如，如果指针是 `int*` 类型，那么每次递增将跳过一个 `int` 的大小（通常是 4 个字节）。

<span style="color: rgb(238,130,238);">**示例：**</span>

```cpp
#include <iostream>
using namespace std;
int main()
{
    int arr[] = {10, 20, 30, 40, 50};
    int* ptr = arr;  // 指向数组的第一个元素
    cout << "指针当前指向的元素: " << *ptr << endl;
    ptr++;  // 递增指针，指向下一个元素
    cout << "递增指针后指向的元素: " << *ptr << endl;
    return 0;
}
```

<span style="color: rgb(238,130,238);">**输出：**</span>

```yaml
指针当前指向的元素: 10
递增指针后指向的元素: 20
```

在这个例子中，`ptr++` 使得指针指向数组中的下一个元素。由于 `ptr` 是 `int*` 类型，递增后指针值会增加 4 个字节（假设 `int` 类型占 4 个字节）。

#### <span style="color: rgb(32,178,170);">**II. 递减指针（`--`）**</span> 

指针递减时，会使指针指向上一个内存位置，通常是前一个数组元素。递减的偏移量同样取决于指针的数据类型。

<span style="color: rgb(238,130,238);">**示例：**</span>

```cpp
#include <iostream>
using namespace std;
int main()
{
    int arr[] = {10, 20, 30, 40, 50};
    int* ptr = &arr[1];  // 指向数组的第二个元素
    cout << "指针当前指向的元素: " << *ptr << endl;
    ptr--;  // 递减指针，指向前一个元素
    cout << "递减指针后指向的元素: " << *ptr << endl;
    return 0;
}
```

<span style="color: rgb(238,130,238);">**输出：**</span>

```yaml
指针当前指向的元素: 20
递减指针后指向的元素: 10
```

在这个例子中，`ptr--` 使得指针指向前一个元素。由于 `ptr` 是 `int*` 类型，递减后指针值会减少 4 个字节。

#### <span style="color: rgb(32,178,170);">**III. 指针加法（`+`）**</span> 

你可以对指针进行加法运算。当指针 `p` 加上一个整数 `n` 时，指针会向前移动 `n` 个元素的大小。例如，如果 `p` 是一个 `int*` 类型，每个 `int` 占 4 个字节，那么 `p + 1` 将指向下一个 `int` 元素。

<span style="color: rgb(238,130,238);">**示例：**</span>

```cpp
#include <iostream>
using namespace std;
int main()
{
    int arr[] = {10, 20, 30, 40, 50};
    int* ptr = arr;  // 指向数组的第一个元素
    // 输出 ptr + 2 指向的元素（向前移动 2 个元素）
    cout << "ptr + 2 指向的元素: " << *(ptr + 2) << endl;
    return 0;
}
```

<span style="color: rgb(238,130,238);">**输出：**</span>

```yaml
ptr + 2 指向的元素: 30
```

在这个例子中，`ptr + 2` 会使指针向前移动 2 个 `int` 元素的位置，相当于将 `ptr` 指向 `arr[2]`。

#### <span style="color: rgb(32,178,170);">**IV. 指针减法（`-`）**</span> 

你也可以对指针进行减法运算。当指针 `p` 减去一个整数 `n` 时，指针会向后移动 `n` 个元素的大小。与加法运算类似，指针减法的偏移量同样取决于指针的数据类型。

<span style="color: rgb(238,130,238);">**示例：**</span>

```cpp
#include <iostream>
using namespace std;
int main()
{
    int arr[] = {10, 20, 30, 40, 50};
    int* ptr = &arr[4];  // 指向数组的最后一个元素
    // 输出 ptr - 2 指向的元素（向后移动 2 个元素）
    cout << "ptr - 2 指向的元素: " << *(ptr - 2) << endl;
    return 0;
}
```

<span style="color: rgb(238,130,238);">**输出：**</span>

```yaml
ptr - 2 指向的元素: 30
```

在这个例子中，`ptr - 2` 会使指针向后移动 2 个 `int` 元素的位置，相当于将 `ptr` 指向 `arr[2]`。

#### <span style="color: rgb(32,178,170);">*V. 指针与指针之间的减法**</span> 

你还可以对两个指针进行减法运算，计算它们之间的距离。减法结果是两个指针之间的元素个数。

<span style="color: rgb(238,130,238);">**示例：**</span>

```cpp
#include <iostream>
using namespace std;
int main()
{
    int arr[] = {10, 20, 30, 40, 50};
    int* ptr1 = &arr[1];  // 指向数组的第二个元素
    int* ptr2 = &arr[4];  // 指向数组的第五个元素
    // 输出 ptr2 - ptr1 的结果，表示它们之间的元素个数
    cout << "ptr2 - ptr1 之间的元素个数: " << ptr2 - ptr1 << endl;
    return 0;
}
```

<span style="color: rgb(238,130,238);">**输出：**</span>

```yaml
ptr2 - ptr1 之间的元素个数: 3
```

在这个例子中，`ptr2 - ptr1` 计算的是两个指针之间的元素个数。由于 `ptr1` 和 `ptr2` 分别指向 `arr[1]` 和 `arr[4]`，它们之间有 3 个 `int` 元素。

#### <span style="color: rgb(32,178,170);">**VI. 指针比较**</span> 

C++ 中还可以比较两个指针的相对位置。指针的比较包括相等性比较和关系比较：

- **相等性比较**：`==` 和 `!=`
- **关系比较**：`<`, `<=`, `>`, `>=`

<span style="color: rgb(238,130,238);">**示例：**</span>

```cpp
#include <iostream>
using namespace std;
int main()
{
    int arr[] = {10, 20, 30, 40, 50};
    int* ptr1 = &arr[1];  // 指向数组的第二个元素
    int* ptr2 = &arr[3];  // 指向数组的第四个元素
    // 相等性比较
    if (ptr1 == ptr2)
    {
        cout << "ptr1 和 ptr2 指向相同的位置" << endl;
    }
    else
    {
        cout << "ptr1 和 ptr2 指向不同的位置" << endl;
    }
    // 关系比较
    if (ptr1 < ptr2)
    {
        cout << "ptr1 指向的元素在 ptr2 指向的元素之前" << endl;
    }
    return 0;
}
```

<span style="color: rgb(238,130,238);">**输出：**</span>

```yaml
ptr1 和 ptr2 指向不同的位置
ptr1 指向的元素在 ptr2 指向的元素之前
```

在这个例子中，我们比较了两个指针 `ptr1` 和 `ptr2`，检查它们是否指向同一位置，以及它们的相对位置。

### <span style="color: rgb(32,178,170);">**注意事项**</span> 
1. **指针操作的有效性**：指针算术运算需要确保指针仍指向有效的内存位置，尤其是在操作数组时，避免指针超出数组的有效范围。
2. **指针类型与大小**：指针算术运算是基于指针所指向的数据类型大小进行的。例如，`int*` 指针每次递增会增加 4 个字节（假设 `int` 是 4 字节）。
3. **空指针比较**：在进行指针比较之前，确保指针不是空指针（`nullptr`），否则可能会导致未定义行为。

通过这些算术运算和比较，你可以更加灵活和高效地操作指针，尤其是在处理数组和动态内存时。

### <span style="color: rgb(0,191,255);">**3.C++ 指针 vs 数组**</span>

指针和数组在 C++ 中密切相关，甚至可以说它们在很多情况下是可以互换的。数组名实际上是一个常量指针，指向数组的首元素。你可以通过指针的算术运算或数组索引来访问数组元素。尽管如此，指针和数组在使用上仍然有一些区别，需要理解它们之间的关系和限制。

#### <span style="color: rgb(32,178,170);">**I. 指针和数组的相似性**</span> 

指针和数组在某些场景下非常相似，特别是在访问数组元素时。数组名本质上是一个指针常量，指向数组的第一个元素。因此，指针可以用来遍历数组。

<span style="color: rgb(238,130,238);">**示例：**</span>

```cpp
#include <iostream>
using namespace std;
const int MAX = 3;
int main()
{
    int var[MAX] = {10, 100, 200};
    int *ptr;
    // 指针指向数组的第一个元素
    ptr = var;  
    for (int i = 0; i < MAX; i++)
    {
        cout << "var[" << i << "]的内存地址为 " << ptr << endl;
        cout << "var[" << i << "] 的值为 " << *ptr << endl;
        // 使用指针递增来访问下一个数组元素
        ptr++;
    }
    return 0;
}
```

<span style="color: rgb(238,130,238);">**输出：**</span>

```yaml
var[0]的内存地址为 0x7fff59707adc
var[0] 的值为 10
var[1]的内存地址为 0x7fff59707ae0
var[1] 的值为 100
var[2]的内存地址为 0x7fff59707ae4
var[2] 的值为 200
```

在这个示例中，`ptr` 是一个指针，它首先指向数组 `var` 的首元素。通过指针递增 `ptr++`，指针依次指向数组的下一个元素。你可以看到，数组和指针之间的关系非常密切，指针就像是数组名的别名，可以通过指针访问数组元素。

#### <span style="color: rgb(32,178,170);">**II.数组名和指针常量**</span> 

虽然数组名在表达式中表现得像一个指针，但它本质上是一个指向数组首元素的常量指针。这意味着你不能修改数组名本身（即使数组是静态分配的），只能通过修改数组元素的值来修改数组内容。

<span style="color: rgb(238,130,238);">**错误示例：**</span>

```cpp
#include <iostream>
using namespace std;
const int MAX = 3;
int main()
{
    int var[MAX] = {10, 100, 200};
    for (int i = 0; i < MAX; i++)
    {
        *var = i;    // 正确：修改 var[0] 的值
        var++;       // 错误：试图修改数组名 var，它是一个常量指针
    }
    return 0;
}
```

在上面的代码中，`*var = i;` 是合法的，它会将 `var[0]` 的值设置为 `i`。但是，`var++` 是不合法的，因为 `var` 是一个指向数组首元素的常量指针，不能修改 `var` 的值。数组名本质上是一个常量指针，指向数组的第一个元素，因此你无法更改它的值。

#### <span style="color: rgb(32,178,170);">**III. 使用指针语法访问数组元素**</span> 

虽然数组名本身不能作为左值（即不能直接修改数组名），但你可以使用指针语法来修改数组的元素。例如，下面的代码演示了如何通过指针运算来访问和修改数组元素。

<span style="color: rgb(238,130,238);">**有效示例：**</span>

```cpp
#include <iostream>
using namespace std;
const int MAX = 3;
int main()
{
    int var[MAX] = {10, 100, 200};
    // 使用指针运算修改 var[2] 的值
    *(var + 2) = 500;
    // 输出修改后的数组元素
    for (int i = 0; i < MAX; i++)
    {
        cout << "var[" << i << "] = " << var[i] << endl;
    }
    return 0;
}
```

<span style="color: rgb(238,130,238);">**输出：**</span>

```yaml
var[0] = 10
var[1] = 100
var[2] = 500
```

在这个例子中，`*(var + 2) = 500;` 是合法的，因为 `var + 2` 计算的是数组中第 3 个元素的地址（即 `var[2]`）。通过指针语法，可以修改数组中的元素，而不需要直接修改数组名。

#### <span style="color: rgb(32,178,170);">**IV. 数组与指针的区别**</span> 

尽管指针和数组在很多情况下可以互换，但它们仍然有一些本质的区别：

1. **数组名是常量**：数组名是指向数组首元素的常量指针，不能改变。例如，`var++` 是非法的，因为 `var` 是常量指针。

2. **指针可以修改**：指针本身是变量，可以改变其指向的内存位置。例如，你可以通过 `ptr++` 来改变指针指向数组中的下一个元素。

3. **数组大小固定**：数组在定义时大小固定，不可改变。例如，`int var[3]` 定义了一个大小为 3 的数组。

4. **指针可以指向动态分配的内存**：指针可以动态地指向通过 `new` 或 `malloc` 分配的内存区域，这使得它们比数组更灵活。

### <span style="color: rgb(32,178,170);">**总结**</span> 

- 数组名和指针紧密相关，但数组名是常量指针，不能修改。
- 可以通过指针语法来访问和修改数组元素，但不能修改数组名本身。
- 指针比数组更加灵活，因为指针可以指向动态分配的内存，并且可以通过算术运算调整指向的内存位置。

了解指针和数组之间的关系，以及它们各自的特性，有助于编写更高效、更灵活的 C++ 程序。

### <span style="color: rgb(0,191,255);">**4.C++ 指针数组**</span>

在 C++ 中，指针数组是一个存储指针的数组。指针数组的每个元素都是一个指向某种数据类型的指针。与普通的数组不同，指针数组的元素不是直接存储数据，而是存储数据的地址。

让我们先通过一些简单的实例来理解指针数组的概念。

#### <span style="color: rgb(32,178,170);">**I. 普通数组的例子**</span>  

首先，来看一个普通的整型数组的例子。我们有一个包含 3 个整型元素的数组 `var`：

```cpp
#include <iostream>
using namespace std;
const int MAX = 3;
int main()
{
    int var[MAX] = {10, 100, 200};
    for (int i = 0; i < MAX; i++)
    {
        cout << "Value of var[" << i << "] = " << var[i] << endl;
    }
    return 0;
}
```

<span style="color: rgb(238,130,238);">**输出：**</span>

```yaml
Value of var[0] = 10
Value of var[1] = 100
Value of var[2] = 200
```

这个例子演示了如何声明一个数组，并使用数组的索引来访问每个元素。

#### <span style="color: rgb(32,178,170);">**II. 指针数组的定义**</span> 

接下来，假设我们希望创建一个数组，该数组的每个元素都是一个指向整数的指针。那么，我们就可以使用指针数组。下面是一个包含 3 个整型指针的数组 `ptr` 的例子：

```cpp
#include <iostream>
using namespace std;
const int MAX = 3;
int main()
{
    int var[MAX] = {10, 100, 200};
    int *ptr[MAX];  // 定义一个指向整型的指针数组
    // 将 ptr 中的每个元素指向 var 数组中的元素
    for (int i = 0; i < MAX; i++)
    {
        ptr[i] = &var[i]; // 将指针指向 var[i] 的地址
    }
    // 输出 ptr 数组指向的值
    for (int i = 0; i < MAX; i++)
    {
        cout << "Value of var[" << i << "] = " << *ptr[i] << endl;
    }
    return 0;
}
```

<span style="color: rgb(238,130,238);">**输出：**</span>

```yaml
Value of var[0] = 10
Value of var[1] = 100
Value of var[2] = 200
```

在这个例子中，`ptr` 是一个指向整型的指针数组。我们将 `ptr[i]` 赋值为 `&var[i]`，即将 `ptr[i]` 指向 `var[i]` 的地址。然后，通过解引用 `*ptr[i]` 来输出存储在 `var[i]` 中的值。

#### <span style="color: rgb(32,178,170);">**III. 使用指针数组存储字符串**</span> 

指针数组不仅可以存储整数的地址，还可以存储字符串的地址。比如，下面是一个指向字符的指针数组，它存储了多个字符串的地址：

```cpp
#include <iostream>
using namespace std;
const int MAX = 4;
int main()
{
    const char *names[MAX] ={
        "Zara Ali",
        "Hina Ali",
        "Nuha Ali",
        "Sara Ali"
    };
    for (int i = 0; i < MAX; i++)
    {
        cout << "Value of names[" << i << "] = " << names[i] << endl;
    }
    return 0;
}
```

<span style="color: rgb(238,130,238);">**输出：**</span>

```yaml
Value of names[0] = Zara Ali
Value of names[1] = Hina Ali
Value of names[2] = Nuha Ali
Value of names[3] = Sara Ali
```

在这个例子中，`names` 是一个指向常量字符的指针数组，每个元素指向一个字符串常量。通过遍历数组并输出每个指针所指向的字符串，我们可以显示出这些字符串的值。

#### <span style="color: rgb(32,178,170);">**总结**</span> 

指针数组允许你存储多个指向不同数据类型的指针，这样可以方便地访问和操作多个数据。指针数组的主要特点是：

- **指针数组的每个元素都是一个指针**：这些指针可以指向相同或不同的数据类型。
- **指针数组和普通数组的区别**：普通数组存储数据的值，而指针数组存储数据的地址。
- **用途**：指针数组可以用来存储一组动态数据、字符串列表，甚至可以存储指向结构体或其他复杂类型的指针。

通过指针数组，我们可以灵活地操作一组指向不同数据的指针，使得 C++ 中的内存操作更加高效和灵活。

### <span style="color: rgb(0,191,255);">**5.C++ 指向指针的指针（多级间接寻址）**</span>

在 C++ 中，**指向指针的指针**（也叫做多级间接寻址）是指一个指针变量存储另一个指针的地址，进而可以通过该指针访问实际存储的数据。这种方式的指针链可以更深层次地访问内存内容。

#### <span style="color: rgb(32,178,170);">**I. 定义指向指针的指针**</span> 

指向指针的指针是通过在指针声明中使用两个星号 `**` 来实现的。例如，`int **ptr` 声明了一个指向整型指针的指针。

### <span style="color: rgb(32,178,170);">**II. 指向指针的指针的操作**</span> 

假设我们有一个变量 `var`，它存储了某个值。然后，我们有一个指向 `var` 的指针 `ptr`，接着，再声明一个指向 `ptr` 的指针 `pptr`。这就是一个指向指针的指针的例子。

在这个层次结构中：
- `pptr` 是指向 `ptr` 的指针。
- `ptr` 是指向 `var` 的指针。
- `var` 存储了实际的数据。

访问 `var` 需要通过两次解引用操作：第一次通过 `*ptr` 来获取 `var` 的地址，第二次通过 `**pptr` 来访问 `var` 的值。

### <span style="color: rgb(32,178,170);">**III. 实例：指向指针的指针**</span> 

下面是一个简单的例子，展示了指向指针的指针的用法：

```cpp
#include <iostream>
using namespace std;
int main()
{
    int var;
    int *ptr;
    int **pptr;
    var = 3000;
    // 获取 var 的地址
    ptr = &var;
    // 获取 ptr 的地址
    pptr = &ptr;
    // 输出值
    cout << "var 值为 : " << var << endl;
    cout << "*ptr 值为: " << *ptr << endl;
    cout << "**pptr 值为: " << **pptr << endl;
    return 0;
}
```

<span style="color: rgb(238,130,238);">**输出结果：**</span>

```yaml
var 值为 : 3000
*ptr 值为: 3000
**pptr 值为: 3000
```

### <span style="color: rgb(238,130,238);">**解释：**</span>

1. **`var`** 存储了值 `3000`。
2. **`ptr`** 是一个指针，它存储了 `var` 的地址，即 `ptr = &var`。
3. **`pptr`** 是一个指针，它存储了 `ptr` 的地址，即 `pptr = &ptr`。

在输出时：
- `var` 存储的是 `3000`，直接输出 `var` 就得到了 `3000`。
- `*ptr` 解引用 `ptr`，得到 `var` 的值，即 `3000`。
- `**pptr` 解引用 `pptr` 两次：第一次通过 `*pptr` 得到 `ptr`，第二次通过 `*ptr` 获取 `var` 的值 `3000`。

### <span style="color: rgb(32,178,170);">**总结**</span> 

指向指针的指针的主要特点是通过多级间接寻址，可以实现更加复杂的内存访问。这种机制通常用于需要操作指针本身的情况，例如在函数中修改指针的值或处理二维数组时非常有用。通过多级指针，我们能够间接地访问更深层次的内存数据，提供了更大的灵活性和控制。

### <span style="color: rgb(0,191,255);">**6.C++ 传递指针给函数**</span>

在 C++ 中，您可以将指针传递给函数。这种方式允许函数直接操作传递给它的变量或数组，特别是当需要修改传入的值时非常有用。与传值调用相比，传递指针可以节省内存和时间，特别是在处理大型数据结构时。

#### <span style="color: rgb(32,178,170);">**I. 传递指针给函数**</span> 

要传递指针给函数，只需将函数参数声明为指针类型。在函数内部，您可以通过解引用（`*`）指针来访问或修改指向的值。

### <span style="color: rgb(32,178,170);">**II. 示例 1：传递指针给函数**</span> 

在下面的例子中，我们传递一个 `unsigned long` 型的指针给函数，并在函数内修改这个值。函数 `getSeconds` 会通过指针修改传入的 `sec` 变量，记录当前的时间戳。

```cpp
#include <iostream>
#include <ctime>
using namespace std;
// 函数声明
void getSeconds(unsigned long *par);
int main()
{
    unsigned long sec;
    // 传递 sec 的地址（即指针）
    getSeconds(&sec);
    // 输出实际值
    cout << "Number of seconds: " << sec << endl;
    return 0;
}
// 函数定义
void getSeconds(unsigned long *par)
{
    // 使用 *par 来修改传入的变量
    *par = time(NULL);
}
```

<span style="color: rgb(238,130,238);">**输出：**</span>

```yaml
Number of seconds: 1294450468
```

在这个示例中：
- `getSeconds` 函数接受一个 `unsigned long*` 类型的参数，并通过 `*par` 访问和修改实际的 `sec` 变量。
- 在 `main` 函数中，我们通过 `&sec` 将 `sec` 变量的地址传递给 `getSeconds`，从而使得该函数能够修改 `sec` 的值。

### <span style="color: rgb(32,178,170);">**III. 示例 2：传递指针给数组**</span> 

C++ 中，数组的名称本质上就是指向数组第一个元素的指针。因此，您也可以传递一个数组给函数，函数会收到该数组的地址。通过数组指针，函数可以访问和操作数组的元素。

下面的例子展示了如何将数组传递给函数，并计算数组的平均值：

```cpp
#include <iostream>
using namespace std;
// 函数声明
double getAverage(int *arr, int size);
int main()
{
    // 定义一个包含 5 个元素的数组
    int balance[5] = {1000, 2, 3, 17, 50};
    double avg;
    // 传递指向数组的指针
    avg = getAverage(balance, 5);
    // 输出返回的平均值
    cout << "Average value is: " << avg << endl;
    return 0;
}
// 函数定义
double getAverage(int *arr, int size)
{
    int sum = 0;
    // 遍历数组，计算和
    for (int i = 0; i < size; ++i)
    {
        sum += arr[i];
    }
    // 计算并返回平均值
    return static_cast<double>(sum) / size;
}
```

<span style="color: rgb(238,130,238);">**输出：**</span>

```yaml
Average value is: 214.4
```

在这个示例中：
- `getAverage` 函数接受一个指向整数数组的指针和数组的大小 `size`，并通过该指针访问数组元素，计算数组的和。
- 数组名 `balance` 自动转换为指向其第一个元素的指针，因此可以直接传递给函数。
- 使用 `arr[i]` 访问数组元素，通过指针进行间接访问。

### <span style="color: rgb(32,178,170);">**总结**</span> 

- **指针传递**可以让函数修改传入的值，因为函数接收到的是指针，允许它直接访问内存中的数据。
- **数组作为指针**：C++ 中，数组名本质上是指向数组首元素的指针，因此，传递数组时实际上就是传递一个指向数组首元素的指针。
- **优点**：传递指针比传递整个数组或结构体更高效，特别是当数组或结构体很大时。

这种方式不仅有助于函数修改外部变量，还能显著提高效率。

### <span style="color: rgb(0,191,255);">**7.+ 从函数返回指针**</span>

C++ 允许从函数返回指针，但需要注意一些细节。最关键的是，返回局部变量的指针是不安全的，因为局部变量在函数返回后会被销毁。不过，如果返回的指针指向的是静态变量或动态分配的内存，则是安全的。

### <span style="color: rgb(32,178,170);">**从函数返回指针的基本语法**</span> 

为了从函数返回一个指针，您需要声明函数的返回类型为指针类型。例如：

```cpp
int* myFunction();
```

这表示 `myFunction` 是一个返回 `int*`（即指向整数的指针）的函数。

### <span style="color: rgb(32,178,170);">**注意事项**</span> 

C++ 不允许直接返回指向局部变量的指针，因为局部变量在函数结束时会被销毁，返回的指针就变成了悬空指针。这种情况下，使用 `static` 关键字定义局部变量可以解决这个问题。使用 `static` 关键字声明的变量在函数退出后不会被销毁，它会一直存在直到程序结束。

<span style="color: rgb(238,130,238);">**示例：从函数返回指针**</span>

下面是一个从函数返回指向数组的指针的示例。此函数生成 10 个随机数，并返回一个指向这些随机数的数组的指针。我们使用 `static` 关键字来确保返回的指针指向的数组在函数结束后仍然有效。

```cpp
#include <iostream>
#include <ctime>
#include <cstdlib>
using namespace std;
// 生成和返回随机数的函数
int* getRandom()
{
    static int r[10];  // 静态数组
    // 设置随机种子
    srand((unsigned)time(NULL));
    // 生成 10 个随机数
    for (int i = 0; i < 10; ++i)
    {
        r[i] = rand();
        cout << r[i] << endl;
    }
    return r;  // 返回指向数组的指针
}
int main()
{
    // 指向整数的指针
    int* p;
    // 调用函数并获取返回的指针
    p = getRandom();
    // 通过指针访问数组元素
    for (int i = 0; i < 10; i++)
    {
        cout << "*(p + " << i << ") : " << *(p + i) << endl;
    }
    return 0;
}
```

### <span style="color: rgb(32,178,170);">**代码解析**</span> 

- **静态数组**：在 `getRandom` 函数中，我们声明了一个静态数组 `r[10]`。因为它是静态的，它会在函数调用结束后仍然存在，不会被销毁。
  
- **`srand` 和 `rand`**：我们使用 `srand` 函数设置随机数生成的种子，`rand` 函数生成一个随机数并存储到数组 `r` 中。

- **返回指针**：函数返回一个指向数组的指针 `r`，在 `main` 函数中，我们接收这个指针，并通过指针访问数组的元素。

<span style="color: rgb(238,130,238);">**运行结果**</span>

当代码被编译并执行时，程序会生成并输出 10 个随机数，并通过指针遍历并显示这些随机数：

```
624723190
1468735695
807113585
976495677
613357504
1377296355
1530315259
1778906708
1820354158
667126415
*(p + 0) : 624723190
*(p + 1) : 1468735695
*(p + 2) : 807113585
*(p + 3) : 976495677
*(p + 4) : 613357504
*(p + 5) : 1377296355
*(p + 6) : 1530315259
*(p + 7) : 1778906708
*(p + 8) : 1820354158
*(p + 9) : 667126415
```

### <span style="color: rgb(32,178,170);">**总结**</span> 

- **静态局部变量**：如果要从函数返回指向数组或变量的指针，必须确保该变量在函数退出后依然存在。可以使用 `static` 关键字来声明静态局部变量，这样它们的生命周期会持续到程序结束。
- **返回动态内存**：另一种常见的做法是动态分配内存（使用 `new` 或 `malloc`），并返回指向动态分配内存的指针。
- **避免返回局部变量的指针**：不要返回指向局部非静态变量的指针，因为这些变量会在函数返回后被销毁，导致悬空指针问题。

这种方式在需要从函数中返回多个值或者处理动态生成的数据时非常有用。